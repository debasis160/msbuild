// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.Build.BackEnd.Logging;
using Microsoft.Build.BuildCheck.Acquisition;
using Microsoft.Build.BuildCheck.Logging;
using Microsoft.Build.BuildCheck.Utilities;
using Microsoft.Build.Experimental.BuildCheck;
using Microsoft.Build.Framework;

namespace Microsoft.Build.BuildCheck.Infrastructure;
internal sealed class BuildCheckConnectorLogger(
    IBuildAnalysisLoggingContextFactory loggingContextFactory, 
    IBuildCheckManager buildCheckManager,
    bool areStatsEnabled)
    : ILogger
{
    public LoggerVerbosity Verbosity { get; set; }
    public string? Parameters { get; set; }

    private bool _areStatsEnabled = areStatsEnabled;

    public void Initialize(IEventSource eventSource)
    {
        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
        eventSource.BuildFinished += EventSource_BuildFinished;

        if (eventSource is IEventSource4 eventSource4)
        {
            eventSource4.IncludeEvaluationPropertiesAndItems();
        }
    }

    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
    {
        if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
        {
            if (projectEvaluationFinishedEventArgs.ProjectFile?.EndsWith(".metaproj") ?? false)
            {
                return;
            }

            buildCheckManager.ProcessEvaluationFinishedEventArgs(
                loggingContextFactory.CreateLoggingContext(e.BuildEventContext!),
                projectEvaluationFinishedEventArgs);

            buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, e.BuildEventContext!);
        }
        else if (e is ProjectEvaluationStartedEventArgs projectEvaluationStartedEventArgs)
        {
            // Skip autogenerated transient projects (as those are not user projects to be analyzed)
            if (projectEvaluationStartedEventArgs.ProjectFile?.EndsWith(".metaproj") ?? false)
            {
                return;
            }

            buildCheckManager.StartProjectEvaluation(BuildCheckDataSource.EventArgs, e.BuildEventContext!,
                projectEvaluationStartedEventArgs.ProjectFile!);
        }
        else if (e is ProjectStartedEventArgs projectStartedEvent)
        {
            buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!);
        }
        else if (e is ProjectFinishedEventArgs projectFinishedEventArgs)
        {
            buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!);
        }
        else if (e is BuildCheckEventArgs buildCheckBuildEventArgs)
        {
            if (buildCheckBuildEventArgs is BuildCheckTracingEventArgs tracingEventArgs)
            {
                if (!tracingEventArgs.IsAggregatedGlobalReport)
                {
                    _stats.Merge(tracingEventArgs.TracingData, (span1, span2) => span1 + span2);
                }
            }
            else if (buildCheckBuildEventArgs is BuildCheckAcquisitionEventArgs acquisitionEventArgs)
            {
                buildCheckManager.ProcessAnalyzerAcquisition(acquisitionEventArgs.ToAnalyzerAcquisitionData());
            }
        }
    }

    private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();

    private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
    {
        BuildEventContext buildEventContext = e.BuildEventContext ?? new BuildEventContext(
            BuildEventContext.InvalidNodeId, BuildEventContext.InvalidTargetId,
            BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);

        LoggingContext loggingContext = loggingContextFactory.CreateLoggingContext(buildEventContext);

        _stats.Merge(buildCheckManager.CreateAnalyzerTracingStats()!, (span1, span2) => span1 + span2);
        LogAnalyzerStats(loggingContext);
    }
    
    private void LogAnalyzerStats(LoggingContext loggingContext)
    {
        Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
        Dictionary<string, TimeSpan> analyzerStats = new Dictionary<string, TimeSpan>();

        foreach (var stat in _stats)
        {
            if (stat.Key.StartsWith(BuildCheckConstants.infraStatPrefix))
            {
                string newKey = stat.Key.Replace(BuildCheckConstants.infraStatPrefix, string.Empty);
                infraStats[newKey] = stat.Value;
            }
            else
            {
                analyzerStats[stat.Key] = stat.Value;
            }
        }

        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
        { BuildEventContext = loggingContext.BuildEventContext };

        loggingContext.LogBuildEvent(statEvent);

        MessageImportance importance = _areStatsEnabled ? MessageImportance.High : MessageImportance.Low;
        loggingContext.LogCommentFromText(importance, $"BuildCheck run times{Environment.NewLine}");
        string infraData = BuildCsvString("Infrastructure run times", infraStats);
        loggingContext.LogCommentFromText(importance, infraData);
        string analyzerData = BuildCsvString("Analyzer run times", analyzerStats);
        loggingContext.LogCommentFromText(importance, analyzerData);
    }

    private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
    {
        return title + Environment.NewLine + String.Join(Environment.NewLine, rowData.Select(a => $"{a.Key},{a.Value}")) + Environment.NewLine;
    }

    public void Shutdown()
    { }
}
